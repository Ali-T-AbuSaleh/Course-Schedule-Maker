1. Preferred Schedule Stress level (1-5):
    Allows the user to specify a stress level for the schedule DURING the semester.
    e.g.: if they specify 2/5, then the program tries to favour schedules with such average.

    Implementation idea:
     use e^(-(x^2)) to make the heuristics peak at the specified stress,
     similar to wanted_points.

2. Specify how far back semesters to take into account for grade averages:
    Allows the user to specify the number of semesters back that they want to take
     into account regarding calculating the courses averages â€“ which play a role for
     calculating the heuristics, and presenting the results.
    This can be useful when the course underwent a big change is a specific year, or
    changed the main lecturer...
    Note: this can be done for each course separately or for all the courses at once.

    Implementation idea:
     override the variable SEMESTERS_TO_TAKE_INTO_ACCOUNT, and save the whole
     data for each course not just the average, to be able to customize like that.

3. Do 2, but automatically with no user input.
    It may be tiresome for users to enter a customized value for each course,
     and it might too generalizing to assume one value for all. So, automation
     seems to be a fitting solution.
    Make a function for each set of grades that finds when to stop going back
     in semesters when calculating the average.

    Implementation idea:
     Use statistics to give a predict of where a "major change" happened in the
      course or where grades have a dramatic shift... and there, this is the
      custom value we get for each course.
     An Idea for that might be bubble search, where we maintain a bubble of size 3 lets say,
      and start from the latest semesters, take the first bubble of courses, and take their average,
      then move the bubble down by one course, take the average, and so on...
      continue doing that and then check where the most recent major jump happened.

4. Use pointers for courses, s.t. every course has only one instance.
    python does not support ptrs directly, but there are methods to simulate it,
     and there is a library that gets C pointers: type "import ctypes", then you
     can convert to pointer by doing: "ptr = ctypes.pointer(x)"



